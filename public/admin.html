<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kent Invest — Admin</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body class="bg admin-body">
  <header class="admin-header">
    <div class="admin-brand">
      <img src="/assets/Kent_Invest_Logo.png" class="brandlogo" alt="Kent Invest" />
      <div>
        <h1>KI – Live Trading Sim Admin</h1>
        <p class="muted">Control rounds, monitor autonomous desks, and follow the tape.</p>
      </div>
    </div>
    <div class="admin-header-actions">
      <button id="resetReloadBtn" class="secondary">Reset &amp; reload defaults</button>
      <button id="reloadBotsBtn" class="secondary">Reload Default Bots</button>
      <button id="applyBotConfigBtn">Apply Bot JSON</button>
    </div>
  </header>

  <main class="admin-grid">
    <section class="panel span-2">
      <div class="panel-header"><h2>Round Controls</h2></div>
      <div class="panel-body">
        <div class="control-row">
          <input id="productName" placeholder="Product name" />
          <input id="startPrice" type="number" inputmode="decimal" placeholder="Start price" />
        </div>
        <div class="control-row">
          <button id="startBtn">Start Round</button>
          <button id="pauseBtn">Pause / Resume</button>
          <button id="restartBtn" class="danger">Force Restart</button>
          <button id="modeToggleBtn" class="secondary">Switch to Volume Mode</button>
        </div>
        <p class="muted" id="modeStatus">Price mode: news-driven with noise shocks.</p>
      </div>
    </section>

    <section class="panel">
      <div class="panel-header"><h2>Player Constraints</h2></div>
      <div class="panel-body">
        <div class="admin-constraints">
          <label>
            <span class="label">Max Position Size</span>
            <input id="maxPositionInput" type="number" min="0" step="1" placeholder="5" />
          </label>
          <label>
            <span class="label">Max Loss</span>
            <input id="maxLossInput" type="number" min="0" step="0.01" placeholder="2000" />
          </label>
        </div>
        <div class="control-row">
          <button id="applyConstraintsBtn">Apply Constraints</button>
        </div>
        <p class="muted small-text status-text" id="constraintStatus">Applies to all players. Clear max loss to disable.</p>
      </div>
    </section>

    <section class="panel">
      <div class="panel-header"><h2>Tick Rate</h2></div>
      <div class="panel-body">
        <div class="admin-constraints">
          <label>
            <span class="label">Ticks per second</span>
            <input id="ticksPerSecondInput" type="number" min="1" step="0.5" placeholder="4" />
          </label>
        </div>
        <div class="control-row">
          <button id="applyTickRateBtn">Apply Tick Rate</button>
        </div>
        <p class="muted small-text status-text" id="tickRateStatus">Controls how often the market advances each second.</p>
      </div>
    </section>

    <section class="panel">
      <div class="panel-header"><h2>News & Scenarios</h2></div>
      <div class="panel-body">
        <input id="newsInput" placeholder="Headline" />
        <div class="control-row">
          <input id="newsDelta" type="number" inputmode="decimal" placeholder="Δ Fair" />
          <input id="newsSentiment" type="number" step="0.1" placeholder="Sentiment" />
          <input id="newsIntensity" type="number" step="0.1" placeholder="Intensity" />
        </div>
        <div class="control-row">
          <button id="pushNewsBtn">Push News</button>
        </div>
        <div class="news-series">
          <div class="series-header">
            <h3>Scenario News Series</h3>
            <span class="muted small-text">Queue headlines and let them drop at random intervals.</span>
          </div>
          <div class="control-row">
            <input id="seriesHeadline" placeholder="Series headline" />
            <input id="seriesDelta" type="number" inputmode="decimal" placeholder="Δ Fair" />
            <input id="seriesSentiment" type="number" step="0.1" placeholder="Sentiment" />
            <input id="seriesIntensity" type="number" step="0.1" placeholder="Intensity" />
            <input id="seriesHalfLife" type="number" step="1" placeholder="Half-life (sec)" />
          </div>
          <div class="control-row">
            <button id="addSeriesBtn" class="secondary">Add to Series</button>
          </div>
          <div id="newsSeriesList" class="series-list"></div>
          <div class="control-row">
            <input id="seriesMinDelay" type="number" min="1" step="1" placeholder="Min delay (sec)" />
            <input id="seriesMaxDelay" type="number" min="1" step="1" placeholder="Max delay (sec)" />
          </div>
          <div class="control-row">
            <button id="startSeriesBtn">Start Random News</button>
            <button id="stopSeriesBtn" class="secondary">Stop Series</button>
          </div>
          <p id="seriesStatus" class="muted small-text">No series running.</p>
        </div>
        <div class="scenario-row">
          <button data-scenario="block-trade-day" class="secondary scenario-btn">Block Trade Day</button>
          <button data-scenario="data-drop" class="secondary scenario-btn">Data Drop</button>
          <button data-scenario="thin-book" class="secondary scenario-btn">Thin Book</button>
          <button data-scenario="iceberg-refresh" class="secondary scenario-btn">Iceberg Demo</button>
          <button data-scenario="sticky-book" class="secondary scenario-btn">Sticky Liquidity</button>
        </div>
      </div>
    </section>

    <section class="panel span-2">
      <div class="panel-header"><h2>Live Price</h2></div>
      <div class="panel-body">
        <div class="price-stats">
          <div>
            <span class="label">Last</span>
            <div id="adminLastPrice" class="price-large">–</div>
          </div>
          <div>
            <span class="label">Fair</span>
            <div id="adminFairPrice" class="price-medium">–</div>
          </div>
        </div>
        <div class="chart-wrap">
          <canvas id="adminChart"></canvas>
        </div>
      </div>
    </section>

    <section class="panel span-3">
      <div class="panel-header">
        <h2>Market Metrics</h2>
        <span class="muted">Per-tick mix, spread, and depth</span>
      </div>
      <div class="panel-body metrics-grid">
        <div class="metric-card">
          <div class="metric-head">
            <span class="label">Order Mix</span>
            <span class="pill pill-mode" id="orderMixLabel">—</span>
          </div>
          <canvas id="orderMixCanvas" class="mini-chart"></canvas>
          <p class="muted small-text">Shows market vs limit submissions over the recent window.</p>
        </div>
        <div class="metric-card">
          <div class="metric-head">
            <span class="label">Spread</span>
            <span class="pill pill-mode" id="spreadLabel">—</span>
          </div>
          <canvas id="spreadCanvas" class="mini-chart"></canvas>
          <p class="muted small-text">Live bid/ask spread evolution.</p>
        </div>
        <div class="metric-card">
          <div class="metric-head">
            <span class="label">Depth (Top 3)</span>
            <span class="pill pill-mode" id="depthLabel">—</span>
          </div>
          <canvas id="depthCanvas" class="mini-chart"></canvas>
          <p class="muted small-text">Aggregated bid/ask size at the top three levels.</p>
        </div>
      </div>
    </section>

    <section class="panel span-2">
      <div class="panel-header">
        <h2>Market Order Flow</h2>
        <span class="muted">Cross vs remainder executions</span>
      </div>
      <div class="panel-body">
        <div class="market-flow-grid">
          <div class="market-flow-stat">
            <span class="label">Market Buy Volume</span>
            <div id="marketBuyVolume" class="flow-value">—</div>
          </div>
          <div class="market-flow-stat">
            <span class="label">Market Sell Volume</span>
            <div id="marketSellVolume" class="flow-value">—</div>
          </div>
          <div class="market-flow-stat">
            <span class="label">Cross Volume</span>
            <div id="marketCrossVolume" class="flow-value">—</div>
          </div>
          <div class="market-flow-stat">
            <span class="label">Remainder to Book</span>
            <div id="marketRemainderVolume" class="flow-value">—</div>
          </div>
          <div class="market-flow-stat">
            <span class="label">Market Imbalance</span>
            <div id="marketImbalance" class="flow-value">—</div>
          </div>
        </div>
        <canvas id="marketFlowCanvas" class="mini-chart"></canvas>
        <p class="muted small-text">Tracks imbalance across recent ticks (buying above zero, selling below).</p>
      </div>
    </section>

    <section class="panel">
      <div class="panel-header"><h2>Order Book</h2></div>
      <div class="panel-body">
        <div class="book-meta">
          <span id="adminBookSpread">Spread: —</span>
          <span id="adminBookMode" class="pill pill-mode">—</span>
        </div>
        <div class="orderbook with-depth" id="adminBook"></div>
        <div class="depth-detail" id="adminDepthDetail">
          <p class="muted">Select a price level to see resting orders and owners.</p>
        </div>
      </div>
    </section>

    <section class="panel span-2">
      <div class="panel-header">
        <h2>Autonomous Desks</h2>
        <div class="panel-actions">
          <label class="muted" for="botJson">Paste config JSON</label>
        </div>
      </div>
      <div class="panel-body bot-panel">
        <table id="botTable">
          <thead>
            <tr><th>Bot</th><th>Type</th><th>Status</th><th>Inventory</th><th>PnL</th><th>Cancel/Fill</th></tr>
          </thead>
          <tbody></tbody>
        </table>
        <textarea id="botJson" placeholder='[ { "botType": "MM-Core", ... } ]'></textarea>
      </div>
    </section>

    <section class="panel" id="botDetailPanel">
      <div class="panel-header"><h2>Bot Detail</h2></div>
      <div class="panel-body" id="botDetailBody">
        <p class="muted">Select a bot to inspect parameters, risk, and recent decisions.</p>
      </div>
    </section>

    <section class="panel span-3">
      <div class="panel-header"><h2>Players</h2></div>
      <div class="panel-body">
        <table id="leaderboard">
          <thead><tr><th>Name</th><th>Position</th><th>PnL</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </section>
  </main>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket     = io();
    const startBtn   = document.getElementById('startBtn');
    const pauseBtn   = document.getElementById('pauseBtn');
    const restartBtn = document.getElementById('restartBtn');
    const pushBtn    = document.getElementById('pushNewsBtn');
    const modeBtn    = document.getElementById('modeToggleBtn');
    const tbody      = document.querySelector('#leaderboard tbody');
    const modeStatus = document.getElementById('modeStatus');
    const lastLbl    = document.getElementById('adminLastPrice');
    const fairLbl    = document.getElementById('adminFairPrice');
    const chartCanvas= document.getElementById('adminChart');
    const chartCtx   = chartCanvas?.getContext('2d');
    const adminBook  = document.getElementById('adminBook');
    const adminSpread= document.getElementById('adminBookSpread');
    const adminMode  = document.getElementById('adminBookMode');
    const resetReloadBtn = document.getElementById('resetReloadBtn');
    const reloadBotsBtn = document.getElementById('reloadBotsBtn');
    const applyBotConfigBtn = document.getElementById('applyBotConfigBtn');
    const botTableBody = document.querySelector('#botTable tbody');
    const botDetailBody = document.getElementById('botDetailBody');
    const botJsonInput = document.getElementById('botJson');
    const scenarioButtons = document.querySelectorAll('.scenario-btn');
    const maxPositionInput = document.getElementById('maxPositionInput');
    const maxLossInput = document.getElementById('maxLossInput');
    const applyConstraintsBtn = document.getElementById('applyConstraintsBtn');
    const constraintStatus = document.getElementById('constraintStatus');
    const ticksPerSecondInput = document.getElementById('ticksPerSecondInput');
    const applyTickRateBtn = document.getElementById('applyTickRateBtn');
    const tickRateStatus = document.getElementById('tickRateStatus');
    const orderMixCanvas = document.getElementById('orderMixCanvas');
    const spreadCanvas = document.getElementById('spreadCanvas');
    const depthCanvas = document.getElementById('depthCanvas');
    const marketFlowCanvas = document.getElementById('marketFlowCanvas');
    const orderMixLabel = document.getElementById('orderMixLabel');
    const spreadLabel = document.getElementById('spreadLabel');
    const depthLabel = document.getElementById('depthLabel');
    const marketBuyVolumeLabel = document.getElementById('marketBuyVolume');
    const marketSellVolumeLabel = document.getElementById('marketSellVolume');
    const marketCrossVolumeLabel = document.getElementById('marketCrossVolume');
    const marketRemainderVolumeLabel = document.getElementById('marketRemainderVolume');
    const marketImbalanceLabel = document.getElementById('marketImbalance');
    const seriesHeadlineInput = document.getElementById('seriesHeadline');
    const seriesDeltaInput = document.getElementById('seriesDelta');
    const seriesSentimentInput = document.getElementById('seriesSentiment');
    const seriesIntensityInput = document.getElementById('seriesIntensity');
    const seriesHalfLifeInput = document.getElementById('seriesHalfLife');
    const seriesMinDelayInput = document.getElementById('seriesMinDelay');
    const seriesMaxDelayInput = document.getElementById('seriesMaxDelay');
    const addSeriesBtn = document.getElementById('addSeriesBtn');
    const startSeriesBtn = document.getElementById('startSeriesBtn');
    const stopSeriesBtn = document.getElementById('stopSeriesBtn');
    const seriesList = document.getElementById('newsSeriesList');
    const seriesStatus = document.getElementById('seriesStatus');

    let currentMode = 'news';
    let pricePoints = [];
    let yLo = null, yHi = null;
    let bookSnapshot = null;
    let botSummary = [];
    let selectedBotId = null;
    let metricsHistory = [];
    let adminBookFetchController = null;
    let selectedBookPrice = null;
    let botDetailRefreshAt = 0;
    const botDetailRefreshMs = 750;
    const newsSeriesEntries = [];

    function setConstraintStatus(message, tone = 'muted') {
      if (!constraintStatus) return;
      constraintStatus.textContent = message;
      constraintStatus.classList.remove('muted', 'status-danger', 'status-success');
      constraintStatus.classList.add(tone);
    }

    function setTickRateStatus(message, tone = 'muted') {
      if (!tickRateStatus) return;
      tickRateStatus.textContent = message;
      tickRateStatus.classList.remove('muted', 'status-danger', 'status-success');
      tickRateStatus.classList.add(tone);
    }

    async function loadConstraints() {
      if (!maxPositionInput || !maxLossInput) return;
      try {
        const res = await fetch('/api/admin/constraints');
        if (!res.ok) throw new Error('constraints fetch failed');
        const data = await res.json();
        const constraints = data.constraints || {};
        if (Number.isFinite(constraints.maxPosition)) {
          maxPositionInput.value = constraints.maxPosition;
        }
        maxLossInput.value = Number.isFinite(constraints.maxLoss) ? constraints.maxLoss : '';
      } catch (err) {
        console.error('Failed to load constraints', err);
        setConstraintStatus('Unable to load constraints.', 'status-danger');
      }
    }

    async function loadTickRate() {
      if (!ticksPerSecondInput) return;
      try {
        const res = await fetch('/api/admin/tick');
        if (!res.ok) throw new Error('tick fetch failed');
        const data = await res.json();
        const ticksPerSecond = Number(data?.tick?.ticksPerSecond);
        if (Number.isFinite(ticksPerSecond)) {
          ticksPerSecondInput.value = ticksPerSecond;
        }
      } catch (err) {
        console.error('Failed to load tick rate', err);
        setTickRateStatus('Unable to load tick rate.', 'status-danger');
      }
    }

    async function applyConstraints() {
      if (!maxPositionInput || !maxLossInput) return;
      const payload = {};
      const maxPositionRaw = maxPositionInput.value.trim();
      if (maxPositionRaw) {
        const parsed = Number(maxPositionRaw);
        if (!Number.isFinite(parsed) || parsed < 0) {
          setConstraintStatus('Enter a valid max position.', 'status-danger');
          return;
        }
        payload.maxPosition = parsed;
      }
      const maxLossRaw = maxLossInput.value.trim();
      if (maxLossRaw === '') {
        payload.maxLoss = null;
      } else {
        const parsed = Number(maxLossRaw);
        if (!Number.isFinite(parsed) || parsed < 0) {
          setConstraintStatus('Enter a valid max loss.', 'status-danger');
          return;
        }
        payload.maxLoss = parsed;
      }
      try {
        setConstraintStatus('Saving constraints...', 'muted');
        const res = await fetch('/api/admin/constraints', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!res.ok) throw new Error('constraints update failed');
        const data = await res.json();
        const constraints = data.constraints || {};
        if (Number.isFinite(constraints.maxPosition)) {
          maxPositionInput.value = constraints.maxPosition;
        }
        maxLossInput.value = Number.isFinite(constraints.maxLoss) ? constraints.maxLoss : '';
        setConstraintStatus('Constraints updated.', 'status-success');
      } catch (err) {
        console.error('Failed to update constraints', err);
        setConstraintStatus('Unable to update constraints.', 'status-danger');
      }
    }

    async function applyTickRate() {
      if (!ticksPerSecondInput) return;
      const raw = ticksPerSecondInput.value.trim();
      if (!raw) {
        setTickRateStatus('Enter ticks per second.', 'status-danger');
        return;
      }
      const parsed = Number(raw);
      if (!Number.isFinite(parsed) || parsed <= 0) {
        setTickRateStatus('Enter a valid tick rate.', 'status-danger');
        return;
      }
      try {
        setTickRateStatus('Saving tick rate...', 'muted');
        const res = await fetch('/api/admin/tick', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ticksPerSecond: parsed }),
        });
        if (!res.ok) throw new Error('tick update failed');
        const data = await res.json();
        const ticksPerSecond = Number(data?.tick?.ticksPerSecond);
        if (Number.isFinite(ticksPerSecond)) {
          ticksPerSecondInput.value = ticksPerSecond;
        }
        setTickRateStatus('Tick rate updated.', 'status-success');
      } catch (err) {
        console.error('Failed to update tick rate', err);
        setTickRateStatus('Unable to update tick rate.', 'status-danger');
      }
    }

    function resizeCanvas(){
      if (!chartCanvas) return;
      const wrap = chartCanvas.parentElement;
      const bb = wrap.getBoundingClientRect();
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
      const w = Math.max(280, Math.floor(bb.width));
      const h = Math.max(180, Math.floor(w*0.45));
      chartCanvas.width = Math.floor(w*dpr);
      chartCanvas.height = Math.floor(h*dpr);
      chartCanvas.style.width = w+'px';
      chartCanvas.style.height = h+'px';
      chartCtx?.setTransform(dpr,0,0,dpr,0,0);
      scheduleDraw();
    }

    function describeMode(mode){
      if(mode==='orderflow'){
        return 'Price mode: volume-driven impact from players & bots.';
      }
      return 'Price mode: news-driven drift with stochastic noise.';
    }

    function updateModeUi(mode){
      currentMode = mode;
      if (modeBtn) {
        modeBtn.textContent = mode === 'orderflow' ? 'Switch to News Mode' : 'Switch to Volume Mode';
      }
      if (modeStatus) modeStatus.textContent = describeMode(mode);
      if (adminMode) {
        adminMode.textContent = `${mode === 'orderflow' ? 'Volume' : 'News'} Mode`;
        adminMode.dataset.mode = mode;
      }
    }

    function formatExposure(value){
      const num = Number(value || 0);
      const abs = Math.abs(num);
      if (!Number.isFinite(num) || abs < 1e-4) return '0';
      if (abs >= 100) return num.toFixed(0);
      if (abs >= 10) return num.toFixed(1);
      if (abs >= 1) return num.toFixed(2);
      return num.toFixed(3);
    }

    function formatVolume(value){
      const num = Number(value || 0);
      if (!Number.isFinite(num)) return '0.00';
      if (Math.abs(num) >= 100) return num.toFixed(0);
      if (Math.abs(num) >= 10) return num.toFixed(1);
      return num.toFixed(2);
    }

    function renderDepthDetail(detail){
      const wrap = document.getElementById('adminDepthDetail');
      if (!wrap) return;
      if (!detail || (!detail.bid && !detail.ask)) {
        wrap.innerHTML = '<p class="muted">Select a price level to see resting orders and owners.</p>';
        return;
      }
      const decimals = tickDecimals(detail?.tickSize ?? bookSnapshot?.tickSize ?? 0.01);
      const header = `<h3>Depth @ ${Number(detail.price || 0).toFixed(decimals)}</h3>`;
      const renderSide = (label, side) => {
        if (!side) return `<p class="muted">No ${label.toLowerCase()} depth</p>`;
        const orders = (side.orders || []).map((ord) => `
          <li>
            <span class="side">${label}</span>
            <span>${formatVolume(ord.remaining)}</span>
            <span>${ord.ownerName || ord.ownerId || 'unknown'}${ord.isBot ? ' (bot)' : ''}</span>
          </li>
        `).join('');
        const baseLine = `<li><span class="side">Base</span><span>${formatVolume(side.base)}</span><span class="muted">baseline</span></li>`;
        return `<h4>${label}</h4><ul>${baseLine}${orders || '<li class="muted">No resting orders</li>'}</ul>`;
      };
      wrap.innerHTML = `${header}<div class="depth-cols">${renderSide('Bid', detail.bid)}${renderSide('Ask', detail.ask)}</div>`;
    }

    function setSeriesStatus(message, tone = 'muted') {
      if (!seriesStatus) return;
      seriesStatus.textContent = message;
      seriesStatus.classList.remove('muted', 'status-danger', 'status-success');
      seriesStatus.classList.add(tone);
    }

    function renderSeriesList() {
      if (!seriesList) return;
      if (!newsSeriesEntries.length) {
        seriesList.innerHTML = '<p class="muted small-text">No headlines queued yet.</p>';
        return;
      }
      seriesList.innerHTML = '';
      newsSeriesEntries.forEach((entry, index) => {
        const item = document.createElement('div');
        item.className = 'series-item';
        item.innerHTML = `
          <div class="series-item-text">
            <strong>${entry.text || 'Untitled headline'}</strong>
            <span class="muted small-text">Δ ${Number(entry.delta || 0).toFixed(2)} · Sent ${Number(entry.sentiment || 0).toFixed(2)} · Int ${Number(entry.intensity || 0).toFixed(2)} · HL ${entry.halfLifeSec || 180}s</span>
          </div>
          <button class="secondary series-remove" data-index="${index}">Remove</button>
        `;
        seriesList.appendChild(item);
      });
      seriesList.querySelectorAll('.series-remove').forEach((btn) => {
        btn.addEventListener('click', () => {
          const idx = Number(btn.dataset.index);
          if (!Number.isFinite(idx)) return;
          newsSeriesEntries.splice(idx, 1);
          renderSeriesList();
        });
      });
    }

    function tickDecimals(value){
      if (!Number.isFinite(value)) return 0;
      const text = value.toString();
      if (text.includes('e-')) {
        const [, exp] = text.split('e-');
        return Math.max(0, Number(exp) || 0);
      }
      const parts = text.split('.');
      return parts[1] ? parts[1].length : 0;
    }

    function inferTickSize(prices){
      const sorted = prices.filter(Number.isFinite).sort((a, b) => a - b);
      if (sorted.length < 2) return 1;
      let min = Infinity;
      for (let i = 1; i < sorted.length; i += 1) {
        const diff = sorted[i] - sorted[i - 1];
        if (diff > 1e-9 && diff < min) min = diff;
      }
      return Number.isFinite(min) && min > 0 ? min : 1;
    }

    function normalizePrice(price, decimals){
      return Number(price.toFixed(decimals));
    }

    function renderAdminBook(book){
      if (!adminBook) return;
      bookSnapshot = book;
      if (!book) {
        adminBook.innerHTML = '<div class="book-empty muted">No resting liquidity</div>';
        if (adminSpread) adminSpread.textContent = 'Spread: —';
        return;
      }

      const asks = Array.isArray(book.asks) ? book.asks : [];
      const bids = Array.isArray(book.bids) ? book.bids : [];
      const prices = [...asks, ...bids].map(level => Number(level?.price)).filter(Number.isFinite);
      const tickSize = Number.isFinite(book?.tickSize) ? book.tickSize : inferTickSize(prices);
      const decimals = tickDecimals(tickSize);
      const midPrice = Number(book.lastPrice ?? book.midPrice);
      if (!prices.length && !Number.isFinite(midPrice)) {
        adminBook.innerHTML = '<div class="book-empty muted">No resting liquidity</div>';
        if (adminSpread) adminSpread.textContent = 'Spread: —';
        return;
      }
      const fallbackMid = Number.isFinite(midPrice) ? midPrice : 0;
      const minWithLiquidity = prices.length ? Math.min(...prices) : fallbackMid - 20 * tickSize;
      const maxWithLiquidity = prices.length ? Math.max(...prices) : fallbackMid + 20 * tickSize;
      if (!Number.isFinite(minWithLiquidity) || !Number.isFinite(maxWithLiquidity)) {
        adminBook.innerHTML = '<div class="book-empty muted">No resting liquidity</div>';
        if (adminSpread) adminSpread.textContent = 'Spread: —';
        return;
      }

      const minPrice = normalizePrice(minWithLiquidity, decimals);
      const maxPrice = normalizePrice(maxWithLiquidity, decimals);
      const bestAsk = Number.isFinite(book.bestAsk) ? normalizePrice(book.bestAsk, decimals) : null;
      const bestBid = Number.isFinite(book.bestBid) ? normalizePrice(book.bestBid, decimals) : null;
      const askMap = new Map();
      const bidMap = new Map();
      asks.forEach((level) => {
        const price = normalizePrice(Number(level.price), decimals);
        askMap.set(price, { size: Number(level.size || 0) });
      });
      bids.forEach((level) => {
        const price = normalizePrice(Number(level.price), decimals);
        bidMap.set(price, { size: Number(level.size || 0) });
      });

      const askCumMap = new Map();
      if (Number.isFinite(bestAsk)) {
        let cum = 0;
        const steps = Math.round((maxPrice - bestAsk) / tickSize);
        for (let i = 0; i <= steps; i += 1) {
          const price = normalizePrice(bestAsk + i * tickSize, decimals);
          const vol = askMap.get(price)?.size ?? 0;
          cum += vol;
          askCumMap.set(price, cum);
        }
      }

      const bidCumMap = new Map();
      if (Number.isFinite(bestBid)) {
        let cum = 0;
        const steps = Math.round((bestBid - minPrice) / tickSize);
        for (let i = 0; i <= steps; i += 1) {
          const price = normalizePrice(bestBid - i * tickSize, decimals);
          const vol = bidMap.get(price)?.size ?? 0;
          cum += vol;
          bidCumMap.set(price, cum);
        }
      }

      const volumes = [...askMap.values(), ...bidMap.values()].map((level) => Number(level.size || 0));
      const maxVol = Math.max(1, ...volumes, 1);
      const rows = [];
      const totalSteps = Math.round((maxPrice - minPrice) / tickSize);

      for (let i = 0; i <= totalSteps; i += 1) {
        const price = normalizePrice(maxPrice - i * tickSize, decimals);
        let side = 'midpoint';
        if (Number.isFinite(bestAsk) && price >= bestAsk - tickSize * 0.5) {
          side = 'ask';
        } else if (Number.isFinite(bestBid) && price <= bestBid + tickSize * 0.5) {
          side = 'bid';
        }
        const vol = side === 'ask'
          ? (askMap.get(price)?.size ?? 0)
          : side === 'bid'
            ? (bidMap.get(price)?.size ?? 0)
            : 0;
        const cum = side === 'ask'
          ? (askCumMap.get(price) ?? 0)
          : side === 'bid'
            ? (bidCumMap.get(price) ?? 0)
            : 0;
        const width = Math.min(100, (vol / maxVol) * 100);
        const best = (side === 'ask' && price === bestAsk) || (side === 'bid' && price === bestBid);
        const empty = vol <= 0 ? ' empty' : '';
        rows.push(`<div class="orderbook-row ${side}${best ? ' best' : ''}${empty}" data-price="${price.toFixed(4)}" style="--bar:${width.toFixed(1)}%"><span>${formatVolume(vol)}</span><span>${price.toFixed(2)}</span><span>${formatVolume(cum)}</span></div>`);
      }

      adminBook.innerHTML = rows.join('');
      adminBook.querySelectorAll('.orderbook-row').forEach((row) => {
        row.classList.add('selectable');
        row.addEventListener('click', () => {
          adminBook.querySelectorAll('.orderbook-row.selected').forEach((r) => r.classList.remove('selected'));
          row.classList.add('selected');
          const price = row.dataset.price ? Number(row.dataset.price) : null;
          if (Number.isFinite(price)) {
            selectedBookPrice = price;
            fetch(`/api/book/levels/${price}`)
              .then((res) => res.json())
              .then((data) => renderDepthDetail(data.detail))
              .catch(() => renderDepthDetail(null));
          }
        });
      });
      if (Number.isFinite(selectedBookPrice)) {
        const match = adminBook.querySelector(`.orderbook-row[data-price="${selectedBookPrice.toFixed(4)}"]`);
        if (match) {
          match.classList.add('selected');
          fetch(`/api/book/levels/${selectedBookPrice}`)
            .then((res) => res.json())
            .then((data) => renderDepthDetail(data.detail))
            .catch(() => renderDepthDetail(null));
        }
      }
      if (adminSpread) {
        const spread = Number(book.spread);
        adminSpread.textContent = Number.isFinite(spread) && spread > 0
          ? `Spread: ${spread.toFixed(2)}`
          : 'Spread: —';
      }
    }

    async function fetchAdminBook(levels = 400){
      if (adminBookFetchController) {
        adminBookFetchController.abort();
      }
      adminBookFetchController = new AbortController();
      try {
        const res = await fetch(`/api/admin/book?levels=${levels}`, { signal: adminBookFetchController.signal });
        const data = await res.json();
        renderAdminBook(data.book);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('admin book fetch failed', err);
        }
      } finally {
        adminBookFetchController = null;
      }
    }

    function prepMiniCanvas(canvas){
      if (!canvas) return null;
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
      const bb = canvas.getBoundingClientRect();
      const w = Math.max(200, Math.floor(bb.width));
      const h = Math.max(120, Math.floor(bb.height || 140));
      canvas.width = Math.floor(w*dpr);
      canvas.height = Math.floor(h*dpr);
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return { ctx, w, h };
    }

    function renderOrderMix(){
      if (!orderMixCanvas) return;
      const meta = prepMiniCanvas(orderMixCanvas);
      if (!meta) return;
      const { ctx, w, h } = meta;
      const data = metricsHistory.slice(-200);
      ctx.clearRect(0,0,w,h);
      if (!data.length) return;
      const barW = Math.max(2, w / Math.max(50, data.length));
      data.forEach((m, i) => {
        const share = Math.max(0, Math.min(1, Number(m.marketShare || 0)));
        const x = (i / data.length) * w;
        const y = h * (1 - share);
        ctx.fillStyle = '#6da8ff';
        ctx.fillRect(x, y, barW, h - y);
        ctx.fillStyle = '#2ecc71';
        ctx.fillRect(x, 0, barW, y);
      });
      const latest = data.at(-1);
      if (orderMixLabel && latest) {
        const pct = Math.round((latest.marketShare || 0) * 100);
        orderMixLabel.textContent = `Mkt ${pct}% / Lmt ${100-pct}%`;
      }
    }

    function renderSpreadChart(){
      if (!spreadCanvas) return;
      const meta = prepMiniCanvas(spreadCanvas);
      if (!meta) return;
      const { ctx, w, h } = meta;
      const data = metricsHistory.slice(-200);
      ctx.clearRect(0,0,w,h);
      if (!data.length) return;
      const spreads = data.map(m => Math.max(0, Number(m.spread || 0)));
      const max = Math.max(0.01, Math.max(...spreads));
      ctx.strokeStyle = '#ff9b9b';
      ctx.lineWidth = 2;
      ctx.beginPath();
      spreads.forEach((s, i) => {
        const x = (i/(spreads.length-1||1)) * w;
        const y = h - (s/max) * h;
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();
      const latest = spreads.at(-1);
      if (spreadLabel && Number.isFinite(latest)) {
        spreadLabel.textContent = `${latest.toFixed(3)}`;
      }
    }

    function renderDepthChart(){
      if (!depthCanvas) return;
      const meta = prepMiniCanvas(depthCanvas);
      if (!meta) return;
      const { ctx, w, h } = meta;
      const data = metricsHistory.slice(-200);
      ctx.clearRect(0,0,w,h);
      if (!data.length) return;
      const bids = data.map(m => Number(m.depthTop3?.bid || 0));
      const asks = data.map(m => Number(m.depthTop3?.ask || 0));
      const max = Math.max(1, Math.max(...bids, ...asks));
      const drawSeries = (series, color) => {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        series.forEach((v,i) => {
          const x = (i/(series.length-1||1)) * w;
          const y = h - (v/max) * h;
          if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        });
        ctx.stroke();
      };
      drawSeries(bids, '#8be4b2');
      drawSeries(asks, '#ff9b9b');
      const lastBid = bids.at(-1);
      const lastAsk = asks.at(-1);
      if (depthLabel && Number.isFinite(lastBid) && Number.isFinite(lastAsk)) {
        depthLabel.textContent = `Bid ${lastBid.toFixed(1)} / Ask ${lastAsk.toFixed(1)}`;
      }
    }

    function renderMarketFlow(){
      if (!marketFlowCanvas) return;
      const meta = prepMiniCanvas(marketFlowCanvas);
      if (!meta) return;
      const { ctx, w, h } = meta;
      const data = metricsHistory.slice(-200);
      ctx.clearRect(0,0,w,h);
      if (!data.length) return;
      const values = data.map(m => Number(m.marketImbalance || 0));
      const maxAbs = Math.max(0.05, ...values.map(v => Math.abs(v)));
      const mid = h / 2;
      ctx.strokeStyle = 'rgba(109,168,255,0.25)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, mid);
      ctx.lineTo(w, mid);
      ctx.stroke();
      ctx.strokeStyle = '#6da8ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      values.forEach((v, i) => {
        const x = (i/(values.length-1||1)) * w;
        const y = mid - (v / maxAbs) * (mid - 6);
        if (i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      });
      ctx.stroke();

      const latest = data.at(-1);
      if (latest) {
        if (marketBuyVolumeLabel) marketBuyVolumeLabel.textContent = Number(latest.marketBuyVolume || 0).toFixed(1);
        if (marketSellVolumeLabel) marketSellVolumeLabel.textContent = Number(latest.marketSellVolume || 0).toFixed(1);
        if (marketCrossVolumeLabel) marketCrossVolumeLabel.textContent = Number(latest.marketCrossVolume || 0).toFixed(1);
        if (marketRemainderVolumeLabel) marketRemainderVolumeLabel.textContent = Number(latest.remainderToBookVolume || 0).toFixed(1);
        if (marketImbalanceLabel) {
          const imbalancePct = (Number(latest.marketImbalance || 0) * 100).toFixed(1);
          marketImbalanceLabel.textContent = `${imbalancePct}%`;
        }
      }
    }

    function escapeHtml(str){
      return String(str ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function formatPnL(value){
      const num = Number(value || 0);
      if (!Number.isFinite(num)) return '0.00';
      const prefix = num >= 0 ? '' : '-';
      const abs = Math.abs(num);
      if (abs >= 1000) return `${prefix}${(abs/1000).toFixed(1)}k`;
      if (abs >= 100) return `${prefix}${abs.toFixed(0)}`;
      return `${prefix}${abs.toFixed(2)}`;
    }

    function clampNumber(value, min, max){
      if (!Number.isFinite(value)) return min;
      return Math.min(max, Math.max(min, value));
    }

    function probabilityToPercent(value, fallback = 50){
      const num = Number(value);
      if (!Number.isFinite(num)) return fallback;
      if (num <= 1) return clampNumber(num * 100, 0, 100);
      return clampNumber(num, 0, 100);
    }

    function readPercentInput(input, fallback){
      if (!input) return fallback;
      const parsed = Number(input.value);
      const clamped = Number.isFinite(parsed) ? clampNumber(parsed, 0, 100) : fallback;
      input.value = clamped.toFixed(0);
      return clamped;
    }

    function readRangeInput(input, fallback){
      if (!input) return fallback;
      const parsed = Number(input.value);
      const clamped = Number.isFinite(parsed) ? clampNumber(parsed, 0, 100) : fallback;
      input.value = clamped.toFixed(2).replace(/\.00$/, '');
      return clamped;
    }

    function readIntegerInput(input, fallback){
      if (!input) return fallback;
      const parsed = Number(input.value);
      const clamped = Number.isFinite(parsed) ? Math.max(1, Math.round(parsed)) : fallback;
      input.value = clamped.toFixed(0);
      return clamped;
    }

    function shouldRefreshBotDetail(){
      if (!botDetailBody || !selectedBotId) return false;
      const active = document.activeElement;
      if (active && botDetailBody.contains(active)) return false;
      if (botDetailBody.matches(':hover')) return false;
      const now = Date.now();
      if (now - botDetailRefreshAt < botDetailRefreshMs) return false;
      botDetailRefreshAt = now;
      return true;
    }

    function updateBotSelection(){
      if (!botTableBody) return;
      const rows = botTableBody.querySelectorAll('tr');
      rows.forEach((row) => {
        if (row.dataset.botId === selectedBotId) row.classList.add('active');
        else row.classList.remove('active');
      });
    }

    function renderBots(summary){
      if (!botTableBody) return;
      botSummary = Array.isArray(summary?.bots) ? summary.bots : [];
      botTableBody.innerHTML = '';
      botSummary.forEach((bot) => {
        const tr = document.createElement('tr');
        tr.dataset.botId = bot.id;
        tr.innerHTML = `
          <td>${bot.name || bot.id}</td>
          <td>${bot.type || ''}</td>
          <td>${bot.enabled === false ? 'Paused' : bot.status || 'Active'}</td>
          <td>${formatExposure(bot.inventory ?? 0)}</td>
          <td>${formatPnL(bot.pnl)}</td>
          <td>${(bot.metrics?.cancelToFill ?? 0).toFixed(2)}</td>`;
        tr.addEventListener('click', () => {
          selectedBotId = bot.id;
          updateBotSelection();
          loadBotDetail(bot.id);
        });
        botTableBody.appendChild(tr);
      });
      updateBotSelection();
    }

    function renderBotDetailView(bot){
      if (!botDetailBody) return;
      if (!bot) {
        botDetailBody.innerHTML = '<p class="muted">Select a bot to inspect parameters, risk, and recent decisions.</p>';
        return;
      }
      const metrics = bot.metrics || {};
      const log = Array.isArray(bot.decisionLog) ? bot.decisionLog.slice(-12).reverse() : [];
      const risk = bot.config?.risk || {};
      const latency = bot.latency || {};
      const isSingleRandomBot = bot.type === 'Single-Random' || bot.config?.botType === 'Single-Random';
      const randomConfig = bot.config?.random || {};
      const buyProbabilityPct = probabilityToPercent(
        randomConfig.buyProbability ?? bot.config?.buyProbability,
        50,
      );
      const crossProbabilityPct = probabilityToPercent(
        randomConfig.crossProbability ?? bot.config?.crossProbability,
        0,
      );
      const limitRangePct = Number(randomConfig.limitRangePct ?? bot.config?.limitRangePct ?? 0.01);
      const limitRangePctPercent = clampNumber(
        Number.isFinite(limitRangePct) ? limitRangePct * 100 : 1,
        0,
        100,
      );
      const ordersPerTick = Math.max(
        1,
        Math.round(Number(randomConfig.ordersPerTick ?? bot.config?.ordersPerTick ?? 1)),
      );
      const orderSize = Math.max(
        1,
        Math.round(Number(bot.config?.child?.size ?? bot.config?.orderSize ?? bot.config?.size ?? 1)),
      );
      botDetailBody.innerHTML = `
        <div class="bot-detail-meta">
          <div><span class="label">Type</span><p>${bot.type || '—'}</p></div>
          <div><span class="label">Status</span><p>${bot.enabled === false ? 'Paused' : bot.status || 'Active'}</p></div>
          <div><span class="label">Inventory</span><p>${formatExposure(bot.inventory ?? 0)}</p></div>
          <div><span class="label">PnL</span><p>${formatPnL(bot.pnl)}</p></div>
        </div>
        <div class="bot-detail-grid">
          <div><span class="label">Latency</span><p>${(latency.mean ?? '—')}ms ± ${(latency.jitter ?? '—')}ms</p></div>
          <div><span class="label">Cancel / Fill</span><p>${(metrics.cancelToFill ?? 0).toFixed(2)}</p></div>
          <div><span class="label">Quote Life</span><p>${(metrics.avgQuoteLifeMs ?? 0).toFixed(0)}ms</p></div>
          <div><span class="label">Total Volume</span><p>${formatExposure(metrics.totalVolume ?? 0)}</p></div>
        </div>
        <div class="bot-detail-grid">
          <div><span class="label">Max Loss</span><p>${formatPnL(risk.maxLoss)}</p></div>
          <div><span class="label">Drawdown</span><p>${formatPnL(risk.maxDrawdown)}</p></div>
          <div><span class="label">Kill Switch</span><p>${risk.killSwitch ? 'Armed' : 'Off'}</p></div>
        </div>
        ${isSingleRandomBot ? `
        <h3>Single Random Bot Controls</h3>
        <div class="bot-detail-grid">
          <div>
            <label class="label" for="randomBuyProbability">Buy probability (%)</label>
            <input id="randomBuyProbability" type="number" min="0" max="100" step="1" value="${buyProbabilityPct}">
          </div>
          <div>
            <label class="label" for="randomLimitRange">Limit range (%)</label>
            <input id="randomLimitRange" type="number" min="0" max="100" step="0.1" value="${limitRangePctPercent}">
          </div>
          <div>
            <label class="label" for="randomCrossProbability">Cross probability (%)</label>
            <input id="randomCrossProbability" type="number" min="0" max="100" step="1" value="${crossProbabilityPct}">
          </div>
          <div>
            <label class="label" for="randomOrdersPerTick">Orders per tick</label>
            <input id="randomOrdersPerTick" type="number" min="1" step="1" value="${ordersPerTick}">
          </div>
          <div>
            <label class="label" for="randomOrderSize">Order size (units)</label>
            <input id="randomOrderSize" type="number" min="1" step="1" value="${orderSize}">
          </div>
        </div>
        <p class="muted">Probabilities clamp to 0–100%. Limit range is applied as a percent around the anchor price.</p>
        <div class="bot-detail-actions">
          <button id="applyRandomBotBtn" class="primary">Apply changes</button>
        </div>
        ` : ''}
        <div class="bot-detail-actions">
          <button id="toggleBotBtn" class="secondary">${bot.enabled === false ? 'Enable Bot' : 'Pause Bot'}</button>
        </div>
        <h3>Recent Decisions</h3>
        <ul class="bot-log">${log.map(item => `<li><span>${new Date(item.t).toLocaleTimeString()}</span><code>${escapeHtml(item.message || item.action || JSON.stringify(item))}</code></li>`).join('')}</ul>
      `;
      const toggleBtn = document.getElementById('toggleBotBtn');
      if (toggleBtn) {
        toggleBtn.onclick = async () => {
          try {
            await fetch(`/api/bots/${bot.id}/toggle`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ enabled: bot.enabled === false }),
            });
            fetchBotSummary();
            loadBotDetail(bot.id);
          } catch (err) {
            console.error('toggle failed', err);
          }
        };
      }
      if (isSingleRandomBot) {
        const applyBtn = document.getElementById('applyRandomBotBtn');
        const buyInput = document.getElementById('randomBuyProbability');
        const limitInput = document.getElementById('randomLimitRange');
        const crossInput = document.getElementById('randomCrossProbability');
        const ordersInput = document.getElementById('randomOrdersPerTick');
        const sizeInput = document.getElementById('randomOrderSize');
        if (applyBtn) {
          applyBtn.onclick = async () => {
            const buyPct = readPercentInput(buyInput, buyProbabilityPct);
            const limitPct = readRangeInput(limitInput, limitRangePctPercent);
            const crossPct = readPercentInput(crossInput, crossProbabilityPct);
            const orders = readIntegerInput(ordersInput, ordersPerTick);
            const size = readIntegerInput(sizeInput, orderSize);
            try {
              const res = await fetch(`/api/bots/${bot.id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  random: {
                    buyProbability: buyPct / 100,
                    crossProbability: crossPct / 100,
                    limitRangePct: limitPct / 100,
                    ordersPerTick: orders,
                  },
                  child: { size },
                }),
              });
              if (!res.ok) throw new Error('patch failed');
              await res.json();
              await loadBotDetail(bot.id);
              await fetchBotSummary();
            } catch (err) {
              console.error('random bot patch failed', err);
              alert('Failed to update bot settings.');
            }
          };
        }
      }
    }

    async function loadBotDetail(id){
      try {
        const res = await fetch(`/api/bots/${id}`);
        if (!res.ok) throw new Error('failed');
        const data = await res.json();
        renderBotDetailView(data.bot);
      } catch (err) {
        console.error('bot detail', err);
      }
    }

    async function fetchBotSummary(){
      try {
        const res = await fetch('/api/bots');
        if (!res.ok) throw new Error('failed');
        const data = await res.json();
        renderBots(data);
        if (selectedBotId) {
          const found = data.bots?.find((b) => b.id === selectedBotId);
          if (!found) {
            selectedBotId = null;
            renderBotDetailView(null);
          }
        }
      } catch (err) {
        console.error('fetch bots', err);
      }
    }

    function ingestMetric(entry){
      if (!entry) return;
      metricsHistory.push(entry);
      if (metricsHistory.length > 360) metricsHistory = metricsHistory.slice(-360);
      renderOrderMix();
      renderSpreadChart();
      renderDepthChart();
      renderMarketFlow();
    }

    async function primeMetrics(){
      try {
        const res = await fetch('/api/metrics');
        if (!res.ok) return;
        const data = await res.json();
        const entries = Array.isArray(data.entries) ? data.entries : [];
        entries.forEach((m) => ingestMetric(m));
      } catch (err) {
        console.error('prime metrics', err);
      }
    }

    startBtn.onclick = () => {
      const product = (document.getElementById('productName').value||'').trim() || 'Demo Asset';
      const startPrice = parseFloat(document.getElementById('startPrice').value) || 100;
      socket.emit('startGame', { startPrice, product });
    };
    pauseBtn.onclick = () => socket.emit('pauseGame');
    restartBtn.onclick = () => {
      if (confirm('Restart round? All players will need to re-join.')) socket.emit('restartGame');
    };
    modeBtn.onclick = () => {
      const next = currentMode === 'orderflow' ? 'news' : 'orderflow';
      socket.emit('setPriceMode', { mode: next });
    };
    pushBtn.onclick = () => {
      const text = document.getElementById('newsInput').value.trim();
      const deltaStr = (document.getElementById('newsDelta').value||'').trim();
      const sentimentStr = (document.getElementById('newsSentiment')?.value||'').trim();
      const intensityStr = (document.getElementById('newsIntensity')?.value||'').trim();
      const payload = {
        text,
        delta: parseFloat(deltaStr),
        sentiment: sentimentStr ? parseFloat(sentimentStr) : undefined,
        intensity: intensityStr ? parseFloat(intensityStr) : undefined,
      };
      socket.emit('pushNews', payload);
      document.getElementById('newsInput').value = '';
      document.getElementById('newsDelta').value = '';
      if (document.getElementById('newsSentiment')) document.getElementById('newsSentiment').value = '';
      if (document.getElementById('newsIntensity')) document.getElementById('newsIntensity').value = '';
    };

    if (seriesMinDelayInput && seriesMaxDelayInput) {
      if (!seriesMinDelayInput.value) seriesMinDelayInput.value = '15';
      if (!seriesMaxDelayInput.value) seriesMaxDelayInput.value = '45';
    }

    if (addSeriesBtn) {
      addSeriesBtn.onclick = () => {
        const text = seriesHeadlineInput?.value.trim() || '';
        const deltaStr = seriesDeltaInput?.value.trim() || '';
        const sentimentStr = seriesSentimentInput?.value.trim() || '';
        const intensityStr = seriesIntensityInput?.value.trim() || '';
        const halfLifeStr = seriesHalfLifeInput?.value.trim() || '';
        const delta = deltaStr ? Number(deltaStr) : 0;
        if (!text && !delta) {
          setSeriesStatus('Enter a headline or delta before adding.', 'status-danger');
          return;
        }
        const entry = {
          text,
          delta: Number.isFinite(delta) ? delta : 0,
          sentiment: sentimentStr ? Number(sentimentStr) : undefined,
          intensity: intensityStr ? Number(intensityStr) : undefined,
          halfLifeSec: halfLifeStr ? Number(halfLifeStr) : undefined,
        };
        newsSeriesEntries.push(entry);
        renderSeriesList();
        setSeriesStatus('Headline added to series.', 'status-success');
        if (seriesHeadlineInput) seriesHeadlineInput.value = '';
        if (seriesDeltaInput) seriesDeltaInput.value = '';
        if (seriesSentimentInput) seriesSentimentInput.value = '';
        if (seriesIntensityInput) seriesIntensityInput.value = '';
        if (seriesHalfLifeInput) seriesHalfLifeInput.value = '';
      };
    }

    if (startSeriesBtn) {
      startSeriesBtn.onclick = () => {
        if (!newsSeriesEntries.length) {
          setSeriesStatus('Add at least one headline before starting.', 'status-danger');
          return;
        }
        const minDelay = Number(seriesMinDelayInput?.value || 0);
        const maxDelay = Number(seriesMaxDelayInput?.value || 0);
        if (!Number.isFinite(minDelay) || !Number.isFinite(maxDelay) || minDelay <= 0 || maxDelay <= 0) {
          setSeriesStatus('Enter valid min/max delays.', 'status-danger');
          return;
        }
        const payload = {
          entries: newsSeriesEntries,
          minDelaySec: minDelay,
          maxDelaySec: maxDelay,
        };
        socket.emit('startNewsSeries', payload, (res) => {
          if (res?.ok) {
            setSeriesStatus(res.message || 'Series scheduled.', 'status-success');
          } else {
            setSeriesStatus(res?.message || 'Unable to schedule series.', 'status-danger');
          }
        });
      };
    }

    if (stopSeriesBtn) {
      stopSeriesBtn.onclick = () => {
        socket.emit('stopNewsSeries', {}, (res) => {
          if (res?.ok) {
            setSeriesStatus('Series stopped.', 'status-success');
          } else {
            setSeriesStatus(res?.message || 'Unable to stop series.', 'status-danger');
          }
        });
      };
    }

    if (reloadBotsBtn) {
      reloadBotsBtn.onclick = async () => {
        try {
          await fetch('/api/bots/reload', { method: 'POST', headers: { 'Content-Type': 'application/json' } });
          fetchBotSummary();
          renderBotDetailView(null);
        } catch (err) {
          console.error('reload bots', err);
        }
      };
    }

      if (resetReloadBtn) {
      resetReloadBtn.onclick = async () => {
        try {
          socket.emit('restartGame');
          await fetch('/api/bots/reload', { method: 'POST', headers: { 'Content-Type': 'application/json' } });
          fetchBotSummary();
          renderBotDetailView(null);
        } catch (err) {
          console.error('reset & reload failed', err);
        }
      };
    }

    if (applyBotConfigBtn) {
      applyBotConfigBtn.onclick = async () => {
        if (!botJsonInput) return;
        const raw = botJsonInput.value.trim();
        if (!raw) return;
        try {
          const configs = JSON.parse(raw);
          await fetch('/api/bots/reload', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ configs }),
          });
          botJsonInput.value = '';
          selectedBotId = null;
          renderBotDetailView(null);
          fetchBotSummary();
        } catch (err) {
          console.error('apply bot config', err);
          alert('Invalid JSON payload for bot configuration.');
        }
      };
    }

    if (applyConstraintsBtn) {
      applyConstraintsBtn.onclick = async () => {
        await applyConstraints();
      };
    }

    if (applyTickRateBtn) {
      applyTickRateBtn.onclick = async () => {
        await applyTickRate();
      };
    }

    scenarioButtons.forEach((btn) => {
      btn.addEventListener('click', async () => {
        const scenario = btn.dataset.scenario;
        if (!scenario) return;
        try {
          await fetch(`/api/scenarios/${scenario}`, { method: 'POST' });
        } catch (err) {
          console.error('scenario trigger failed', err);
        }
      });
    });

    function drawChart(){
      if (!chartCtx || pricePoints.length < 2) { chartCtx?.clearRect(0,0,chartCanvas.width, chartCanvas.height); return; }
      const dpr = window.devicePixelRatio||1;
      const w = chartCanvas.width / dpr;
      const h = chartCanvas.height / dpr;
      chartCtx.clearRect(0,0,w,h);

      chartCtx.strokeStyle = 'rgba(255,255,255,.08)';
      chartCtx.lineWidth = 1;
      chartCtx.beginPath();
      for(let i=1;i<=3;i++){ const y=(h/4)*i; chartCtx.moveTo(0,y); chartCtx.lineTo(w,y); }
      chartCtx.stroke();

      const view = pricePoints.slice(-600);
      const rawLo = Math.min(...view);
      const rawHi = Math.max(...view);
      const pad = Math.max(0.25, (rawHi - rawLo) * 0.12);
      const tgtLo = rawLo - pad;
      const tgtHi = rawHi + pad;

      if (yLo === null || yHi === null) { yLo = tgtLo; yHi = tgtHi; }
      if (tgtLo < yLo) yLo = tgtLo; else yLo = yLo + (tgtLo - yLo) * 0.05;
      if (tgtHi > yHi) yHi = tgtHi; else yHi = yHi + (tgtHi - yHi) * 0.05;

      const X = i => (i/(view.length-1||1)) * w;
      const Y = p => h - ((p - yLo)/Math.max(1e-6,(yHi - yLo))) * h;

      chartCtx.strokeStyle = '#6da8ff';
      chartCtx.lineWidth = 2;
      chartCtx.beginPath();
      chartCtx.moveTo(0, Y(view[0]));
      for (let i=1;i<view.length;i++) chartCtx.lineTo(X(i), Y(view[i]));
      chartCtx.stroke();

      chartCtx.fillStyle = '#fff';
      chartCtx.beginPath();
      chartCtx.arc(X(view.length-1), Y(view[view.length-1]), 3, 0, Math.PI*2);
      chartCtx.fill();
    }

    function scheduleDraw(){
      if (scheduleDraw._p) return;
      scheduleDraw._p = true;
      requestAnimationFrame(()=>{ scheduleDraw._p = false; drawChart(); });
    }

    window.addEventListener('resize', () => {
      resizeCanvas();
      renderAdminBook(bookSnapshot);
      renderOrderMix();
      renderSpreadChart();
      renderDepthChart();
    });
    resizeCanvas();
    updateModeUi('news');
    renderAdminBook(null);
    fetchAdminBook();
    fetchBotSummary();
    loadConstraints();
    loadTickRate();
    primeMetrics();

    socket.on('playerList', (rows) => {
      tbody.innerHTML = '';
      rows.sort((a,b)=> b.pnl - a.pnl).forEach(r=>{
        const tr = document.createElement('tr');
        const nameHtml = r.isBot ? `${r.name} <span class="pill pill-bot">BOT</span>` : r.name;
        const position = formatExposure(r.position ?? 0);
        const pnl = Number(r.pnl || 0).toFixed(2);
        tr.innerHTML = `<td>${nameHtml}</td><td>${position}</td><td>${pnl}</td>`;
        tbody.appendChild(tr);
      });
    });

    socket.on('priceMode', (mode)=>{
      updateModeUi(mode === 'orderflow' ? 'orderflow' : 'news');
    });

    socket.on('orderBook', ()=>{
      fetchAdminBook();
    });

    socket.on('priceUpdate', ({ price, fair })=>{
      if (typeof price === 'number') {
        pricePoints.push(price);
        if (pricePoints.length > 720) pricePoints = pricePoints.slice(-720);
        lastLbl.textContent = price.toFixed(2);
        scheduleDraw();
      }

      if (typeof fair === 'number') {
        fairLbl.textContent = fair.toFixed(2);
      }
    });

    socket.on('gameStarted', ({ priceMode, price, fairValue })=>{
      pricePoints = [];
      yLo = yHi = null;
      if (typeof price === 'number') {
        pricePoints.push(price);
        lastLbl.textContent = price.toFixed(2);
      } else if (typeof fairValue === 'number') {
        pricePoints.push(fairValue);
      }
      if (typeof fairValue === 'number') fairLbl.textContent = fairValue.toFixed(2);
      if (priceMode) updateModeUi(priceMode);
      scheduleDraw();
      renderAdminBook(null);
    });

    socket.on('gameReset', () => {
      pricePoints = [];
      yLo = yHi = null;
      lastLbl.textContent = '–';
      fairLbl.textContent = '–';
      updateModeUi('news');
      scheduleDraw();
      renderAdminBook(null);
      fetchAdminBook();
    });

    socket.on('botSummary', (data) => {
      renderBots(data);
      if (selectedBotId) {
        const exists = data?.bots?.some((b) => b.id === selectedBotId);
        if (!exists) {
          selectedBotId = null;
          renderBotDetailView(null);
        }
      }
    });

    socket.on('botDecision', ({ botId, decision }) => {
      if (botId !== selectedBotId) return;
      const logList = botDetailBody?.querySelector('.bot-log');
      if (!logList) return;
      const li = document.createElement('li');
      const when = new Date(decision?.t || Date.now()).toLocaleTimeString();
      const message = decision?.message || decision?.action || JSON.stringify(decision);
      li.innerHTML = `<span>${when}</span><code>${escapeHtml(message)}</code>`;
      logList.prepend(li);
      while (logList.children.length > 12) logList.removeChild(logList.lastChild);
    });

    socket.on('botTelemetry', ({ botId }) => {
      if (botId !== selectedBotId) return;
      if (!shouldRefreshBotDetail()) return;
      loadBotDetail(botId);
    });

    renderSeriesList();

    socket.on('tickMetrics', (entry) => {
      ingestMetric(entry);
    });
  </script>
</body>
</html>
